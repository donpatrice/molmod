
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Internal coordinates &mdash; MolMod v0.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MolMod v0.0 documentation" href="../index.html" />
    <link rel="up" title="MolMod by example" href="examples.html" />
    <link rel="next" title="Pattern-matching in molecular graphs" href="patterns.html" />
    <link rel="prev" title="Working with molecular graphs" href="graph.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="patterns.html" title="Pattern-matching in molecular graphs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="graph.html" title="Working with molecular graphs"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">MolMod v0.0 documentation</a> &raquo;</li>
          <li><a href="examples.html" accesskey="U">MolMod by example</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="internal-coordinates">
<h1>Internal coordinates<a class="headerlink" href="#internal-coordinates" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Internal coordinates are often used to characterize molecular geometries and for
the definition of energy terms in valence force-field models. In general an
internal coordinate can be defined as any function of the Cartesian atomic
coordinates that does not depend on global rotation and translation.</p>
<p>The module <a title="" class="reference external" href="../reference/algo.html#module-molmod.ic"><tt class="xref docutils literal"><span class="pre">molmod.ic</span></tt></a> contains functions for the
internal coordinates listed in the table below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="20%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Name</th>
<th class="head">Number of arguments</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">bond_length</span></tt></td>
<td>2</td>
<td>Distance between two atoms</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">pair_distance</span></tt></td>
<td>2</td>
<td>(idem)</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">bend_cos</span></tt></td>
<td>3</td>
<td>The cosine of a bending angle</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">bend_angle</span></tt></td>
<td>4</td>
<td>The bending angle</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">dihed_cos</span></tt></td>
<td>4</td>
<td>The cosine of a dihedral angle</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">dihed_angle</span></tt></td>
<td>4</td>
<td>The dihedral angle, following IUPAC standard for the sign</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">opbend_angle</span></tt></td>
<td>4</td>
<td>The out of plane bending angle</td>
</tr>
</tbody>
</table>
<p>In addition to the value of
the internal coordinate, it can also compute the first and second order
derivatives of the internal coordinate towards the Cartesian coordinates.
Each internal coordinate function follows the same <a class="reference external" href="http://en.wikipedia.org/wiki/Application_programming_interface">API</a> style, i.e.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">some_ic</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mf">0</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>All mandatory arguments are 3-element numpy arrays with the atomic coordinates
that define the internal coordinate. The last and optional argument determines
which derivatives are computed. By default no derivatives are computed, and the
internal coordinate is returned in a singleton tuple. When <tt class="docutils literal"><span class="pre">deriv==1</span></tt> the
internal coordinate and the gradient are returned in a tuple. When <tt class="docutils literal"><span class="pre">deriv==2</span></tt>
the internal coordinate, the gradient and the Hessian are returned in a tuple.</p>
<p>The implementation is based on a generic schemes that takes care of following
the chain rule for the derivatives, which makes it rather easy to extend this
module with new types of internal coordinates.</p>
<p>The examples and problems below use a propane and dopamine geometry. The latter
is optimized at the B3LYP/6-31G(d) level, followed by a frequency computation.
The computations are carried out with Gaussian03. The formatted checkpoint file
of the frequency job is stripped to include only the section used in this
chapter.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-simple-bond-length">
<h3>A simple bond length<a class="headerlink" href="#a-simple-bond-length" title="Permalink to this headline">¶</a></h3>
<p>This is just a simple example...</p>
<p>File: <tt class="docutils literal"><span class="pre">examples/003_internal_coordinates/a_bond_length.py</span></tt></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></td><td class="code"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># MolMod is a collection of molecular modelling tools for python.</span>
<span class="c"># Copyright (C) 2007 - 2012 Toon Verstraelen &lt;Toon.Verstraelen@UGent.be&gt;, Center</span>
<span class="c"># for Molecular Modeling (CMM), Ghent University, Ghent, Belgium; all rights</span>
<span class="c"># reserved unless otherwise stated.</span>
<span class="c">#</span>
<span class="c"># This file is part of MolMod.</span>
<span class="c">#</span>
<span class="c"># MolMod is free software; you can redistribute it and/or</span>
<span class="c"># modify it under the terms of the GNU General Public License</span>
<span class="c"># as published by the Free Software Foundation; either version 3</span>
<span class="c"># of the License, or (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># MolMod is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<span class="c">#</span>
<span class="c">#--</span>
<span class="c">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">molmod</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># 0) Load the molecule</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s">&quot;dopamine.xyz&quot;</span><span class="p">)</span>
<span class="c"># 1) Compute the length of the hydrogen bond.</span>
<span class="c"># (Atoms 1 and 20 form a hydrogen bond.)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">bond_length</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">20</span><span class="p">]])[</span><span class="mf">0</span><span class="p">]</span>
<span class="c"># The return value of bond_length is a singleton by default. The final</span>
<span class="c"># part `[0]` takes the first value of this singleton.</span>
<span class="k">print</span> <span class="s">&quot;Hydrogen bond length [Angstrom] =&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">/</span><span class="n">angstrom</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="all-bending-angles-in-dopamine">
<h3>All bending angles in dopamine<a class="headerlink" href="#all-bending-angles-in-dopamine" title="Permalink to this headline">¶</a></h3>
<p>We use the graph features to detect all bending angles in the dopamine molecule.
An overview is printed including the atomic indexes and elements involved in
each angle.</p>
<p>File: <tt class="docutils literal"><span class="pre">examples/003_internal_coordinates/b_bending_angles.py</span></tt></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</pre></td><td class="code"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># MolMod is a collection of molecular modelling tools for python.</span>
<span class="c"># Copyright (C) 2007 - 2012 Toon Verstraelen &lt;Toon.Verstraelen@UGent.be&gt;, Center</span>
<span class="c"># for Molecular Modeling (CMM), Ghent University, Ghent, Belgium; all rights</span>
<span class="c"># reserved unless otherwise stated.</span>
<span class="c">#</span>
<span class="c"># This file is part of MolMod.</span>
<span class="c">#</span>
<span class="c"># MolMod is free software; you can redistribute it and/or</span>
<span class="c"># modify it under the terms of the GNU General Public License</span>
<span class="c"># as published by the Free Software Foundation; either version 3</span>
<span class="c"># of the License, or (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># MolMod is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<span class="c">#</span>
<span class="c">#--</span>
<span class="c">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">molmod</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># 0) Load the molecule and set the default graph</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s">&quot;dopamine.xyz&quot;</span><span class="p">)</span>
<span class="n">mol</span><span class="o">.</span><span class="n">set_default_graph</span><span class="p">()</span>

<span class="c"># 1) Build a list of atom indexes involved in angles.</span>
<span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c"># First loop over all atoms on the molecule.</span>
<span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
    <span class="c"># For each atom we will find all bending angles centered at the current</span>
    <span class="c"># atom. For this we construct (an ordered!) list of all bonded neighbors.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
    <span class="c"># The second loop iterates over all neighbors. The enumerate function is</span>
    <span class="c"># used to assign a counter value to the variable index.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c"># The third loop iterates over all other neighbors that came before i1.</span>
        <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">n</span><span class="p">[:</span><span class="n">index</span><span class="p">]:</span>
            <span class="c"># Each triple is stored as an item in the list angles.</span>
            <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">))</span>

<span class="c"># 2) Iterate over all angles, compute and print.</span>
<span class="k">print</span> <span class="s">&quot;An overview of all bending angles in dopamine:&quot;</span>
<span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
    <span class="c"># Notice again the [0] at the end.</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">bend_angle</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[[</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]])[</span><span class="mf">0</span><span class="p">]</span>
    <span class="c"># Python formatting of the indexes, symbols, and the angle in degrees.</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%2i</span><span class="s"> </span><span class="si">%2i</span><span class="s"> </span><span class="si">%2i</span><span class="s">    </span><span class="si">%2s</span><span class="s"> </span><span class="si">%2s</span><span class="s"> </span><span class="si">%2s</span><span class="s">    </span><span class="si">%5.1f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i2</span><span class="p">],</span> <span class="n">angle</span><span class="o">/</span><span class="n">deg</span>
    <span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="simple-force-field-hessian">
<h3>Simple Force-field Hessian<a class="headerlink" href="#simple-force-field-hessian" title="Permalink to this headline">¶</a></h3>
<p>In this example we do a simple computation of a force-field Hessian for the
propane molecule. The force-field in this example model has only bond-stretch
and bending angle terms. We further assume that all internal coordinates are at
the rest-value of the corresponding energy term in the force field. This
facilitates the program as we only have to take into account the force constants
of the energy terms.</p>
<p>The mathematical form of the FF model is:</p>
<div class="math">
<p><img src="../_images/math/9a7d3e01663f97ca53e47445ea0f47b337c1b2e2.png" alt="E_{\text{FF}} =
\sum_{i=1}^{M_\text{bonds}} K_{i,\text{bond}} (b_i - b_{i,0})^2 +
\sum_{i=1}^{M_\text{bends}} K_{i,\text{bend}} (\theta_i - \theta_{i,0})^2." /></p>
</div><p>The Cartesian gradient of the force-field energy becomes:</p>
<div class="math">
<p><img src="../_images/math/e3e1cf4804a257d7a29d289bb00032e4a94081af.png" alt="\frac{\partial E_{\text{FF}}}{\partial x_{j}} =
\sum_{i=1}^{M_\text{bonds}} 2 K_{i,\text{bond}}
    (b_i - b_{i,0}) \frac{\partial b_i}{\partial x_{j}} +
\sum_{i=1}^{M_\text{bends}} 2 K_{i,\text{bend}}
    (\theta_i - \theta_{i,0}) \frac{\partial \theta_i}{\partial x_{j}}" /></p>
</div><p>The Cartesian Hessian of the force-field becomes:</p>
<div class="math">
<p><img src="../_images/math/10b2b4a225812dfd8102b6fce88b77ddfe6c3600.png" alt="\frac{\partial^2 E_{\text{FF}}}{\partial x_{j_1} \partial x_{j_2}} =
\sum_{i=1}^{M_\text{bonds}} 2 K_{i,\text{bond}} \left[
    \frac{\partial b_i}{\partial x_{j_1}} \frac{\partial b_i}{\partial x_{j_2}} +
    (b_i - b_{i,0}) \frac{\partial^2 b}{\partial x_{j_1} \partial x_{j_2}}
\right] +
\sum_{i=1}^{M_\text{bends}} 2 K_{i,\text{bend}} \left[
    \frac{\partial \theta_i}{\partial x_{j_1}} \frac{\partial \theta_i}{\partial x_{j_2}} +
    (\theta_i - \theta_{i,0}) \frac{\partial^2 \theta_i}{\partial x_{j_1} \partial x_{j_2}} +
\right]" /></p>
</div><p>For the sake of a simple example, we assume that all bond lengths and valence
angles are at their optimum such that the second derivatives of the internal
coordinates towards the Cartesian coordinates drop out of the expression for the
Hessian:</p>
<div class="math">
<p><img src="../_images/math/e800aa71f6f19f07b43bb4179e6d1898aed3c419.png" alt="\frac{\partial^2 E_{\text{FF}}}{\partial x_{j_1} \partial x_{j_2}} \approx
\sum_{i=1}^{M_\text{bonds}} 2 K_{i,\text{bond}}
    \frac{\partial b_i}{\partial x_{j_1}} \frac{\partial b_i}{\partial x_{j_2}} +
\sum_{i=1}^{M_\text{bends}} 2 K_{i,\text{bend}}
    \frac{\partial \theta_i}{\partial x_{j_1}} \frac{\partial \theta_i}{\partial x_{j_2}} +" /></p>
</div><p>We use the following force constants.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="25%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Energy term</th>
<th class="head">Force constant</th>
<th class="head">Unit</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>CH bond</td>
<td>310</td>
<td>k cal mol<sup>-1</sup> Å<sup>-2</sup></td>
</tr>
<tr><td>CC bond</td>
<td>220</td>
<td>k cal mol<sup>-1</sup> Å<sup>-2</sup></td>
</tr>
<tr><td>HCH bend</td>
<td>35</td>
<td>k cal mol<sup>-1</sup> rad<sup>-2</sup></td>
</tr>
<tr><td>HCC bend</td>
<td>30</td>
<td>k cal mol<sup>-1</sup> rad<sup>-2</sup></td>
</tr>
<tr><td>CCC bend</td>
<td>60</td>
<td>k cal mol<sup>-1</sup> rad<sup>-2</sup></td>
</tr>
</tbody>
</table>
<p>The program below uses an object-oriented approach to implement the force-field
model. Each energy term is conceived as an object of either the
<tt class="docutils literal"><span class="pre">BondStretchTerm</span></tt> or the <tt class="docutils literal"><span class="pre">BendingAngleTerm</span></tt> class. They both derive from
the <tt class="docutils literal"><span class="pre">HarmonicEnergyTerm</span></tt> class where all the Hessian logic is implemented.
Each term object contains attributes for the force-field parameters and the atom
indexes that are involved in the internal coordinate. The term objects are kept
in a list in the <tt class="docutils literal"><span class="pre">ForceField</span></tt> class that has a method to compute the Hessian
for a given geometry.</p>
<p>File: <tt class="docutils literal"><span class="pre">examples/003_internal_coordinates/c_ff_hessian.py</span></tt></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178</pre></td><td class="code"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># MolMod is a collection of molecular modelling tools for python.</span>
<span class="c"># Copyright (C) 2007 - 2012 Toon Verstraelen &lt;Toon.Verstraelen@UGent.be&gt;, Center</span>
<span class="c"># for Molecular Modeling (CMM), Ghent University, Ghent, Belgium; all rights</span>
<span class="c"># reserved unless otherwise stated.</span>
<span class="c">#</span>
<span class="c"># This file is part of MolMod.</span>
<span class="c">#</span>
<span class="c"># MolMod is free software; you can redistribute it and/or</span>
<span class="c"># modify it under the terms of the GNU General Public License</span>
<span class="c"># as published by the Free Software Foundation; either version 3</span>
<span class="c"># of the License, or (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># MolMod is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<span class="c">#</span>
<span class="c">#--</span>
<span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">molmod</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">HarmonicEnergyTerm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for all energy terms.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_constant</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">icfn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">           Arguments:</span>
<span class="sd">            | ``force_constant`` -- The force constant in atomic units.</span>
<span class="sd">            | ``indexes`` -- The indexes of the atoms in the internal</span>
<span class="sd">                             coordinate. The order must be the same as the order</span>
<span class="sd">                             of the mandatory arguments of icfn.</span>
<span class="sd">            | ``icfn`` -- a function from molmod.ic that can compute the</span>
<span class="sd">                          internal coordinate and its derivatives.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_constant</span> <span class="o">=</span> <span class="n">force_constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">icfn</span> <span class="o">=</span> <span class="n">icfn</span>

    <span class="k">def</span> <span class="nf">add_to_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">hessian</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the contributions of this energy term to the Hessian</span>

<span class="sd">           Arguments:</span>
<span class="sd">            | ``coordinates`` -- A numpy array with 3N Cartesian coordinates.</span>
<span class="sd">            | ``hessian`` -- A matrix for the full Hessian to which this energy</span>
<span class="sd">                             term has to add its contribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Compute the derivatives of the bond stretch towards the two cartesian</span>
        <span class="c"># coordinates. The bond length is computed too, but not used.</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">icfn</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">)],</span> <span class="mf">1</span><span class="p">)</span>
        <span class="c"># Add the contribution to the Hessian (an outer product)</span>
        <span class="k">for</span> <span class="n">ja</span><span class="p">,</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">):</span>
            <span class="c"># ja is 0, 1, 2, ...</span>
            <span class="c"># ia is i0, i1, i2, ...</span>
            <span class="k">for</span> <span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">):</span>
                <span class="n">contrib</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">force_constant</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">ja</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>
                <span class="n">hessian</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="n">ia</span><span class="p">:</span><span class="mf">3</span><span class="o">*</span><span class="n">ia</span><span class="o">+</span><span class="mf">3</span><span class="p">,</span> <span class="mf">3</span><span class="o">*</span><span class="n">ib</span><span class="p">:</span><span class="mf">3</span><span class="o">*</span><span class="n">ib</span><span class="o">+</span><span class="mf">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">contrib</span>


<span class="k">class</span> <span class="nc">BondStretchTerm</span><span class="p">(</span><span class="n">HarmonicEnergyTerm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A single bond-stretch energy term in the force-field term.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_constant</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">           Arguments:</span>
<span class="sd">            | ``force_constant`` -- The force constant in atomic units.</span>
<span class="sd">            | ``i0`` -- The atom index of the first atom in the bond.</span>
<span class="sd">            | ``i1`` -- The atom index of the second atom in the bond.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HarmonicEnergyTerm</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">),</span> <span class="n">bond_length</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BendAngleTerm</span><span class="p">(</span><span class="n">HarmonicEnergyTerm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A single bond-stretch energy term in the force-field term.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_constant</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">           Arguments:</span>
<span class="sd">            | ``force_constant`` -- The force constant in atomic units.</span>
<span class="sd">            | ``i0`` -- The atom index of the first atom in the angle.</span>
<span class="sd">            | ``i1`` -- The atom index of the central atom in the angle.</span>
<span class="sd">            | ``i2`` -- The atom index of the third atom in the angle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HarmonicEnergyTerm</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_constant</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">),</span> <span class="n">bend_angle</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ForceField</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A container object for all force field terms.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">           Argument:</span>
<span class="sd">            | ``terms`` -- a list of force-field terms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>
        <span class="c"># just print out the energy terms</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Energy term&quot;</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">icfn</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">force_constant</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">indexes</span>

    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the force-field Hessian for the given coordinates.</span>

<span class="sd">           Argument:</span>
<span class="sd">            | ``coordinates`` -- A numpy array with the Cartesian atom</span>
<span class="sd">                                 coordinates, with shape (N,3).</span>

<span class="sd">           Returns:</span>
<span class="sd">            | ``hessian`` -- A numpy array with the Hessian, with shape (3*N,</span>
<span class="sd">                             3*N).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># N3 is 3 times the number of atoms.</span>
        <span class="n">N3</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span>
        <span class="c"># Start with a zero hessian.</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N3</span><span class="p">,</span><span class="n">N3</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="c"># Add the contribution of each term.</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="n">term</span><span class="o">.</span><span class="n">add_to_hessian</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">hessian</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hessian</span>


<span class="k">def</span> <span class="nf">setup_hydrocarbon_ff</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a simple ForceField object for hydrocarbons based on the graph.&quot;&quot;&quot;</span>
    <span class="c"># A) Define parameters.</span>
    <span class="c"># the bond parameters:</span>
    <span class="n">bond_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="mf">1</span><span class="p">):</span> <span class="mf">310</span><span class="o">*</span><span class="n">kcalmol</span><span class="o">/</span><span class="n">angstrom</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span>
        <span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="mf">6</span><span class="p">):</span> <span class="mf">220</span><span class="o">*</span><span class="n">kcalmol</span><span class="o">/</span><span class="n">angstrom</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c"># for every (a, b), also add (b, a)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bond_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mf">1</span><span class="p">]:</span>
            <span class="n">bond_params</span><span class="p">[(</span><span class="n">key</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mf">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="c"># the bend parameters</span>
    <span class="n">bend_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">6</span><span class="p">,</span> <span class="mf">1</span><span class="p">):</span> <span class="mf">35</span><span class="o">*</span><span class="n">kcalmol</span><span class="o">/</span><span class="n">rad</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span>
        <span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">6</span><span class="p">,</span> <span class="mf">6</span><span class="p">):</span> <span class="mf">30</span><span class="o">*</span><span class="n">kcalmol</span><span class="o">/</span><span class="n">rad</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span>
        <span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="mf">6</span><span class="p">,</span> <span class="mf">6</span><span class="p">):</span> <span class="mf">60</span><span class="o">*</span><span class="n">kcalmol</span><span class="o">/</span><span class="n">rad</span><span class="o">**</span><span class="mf">2</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c"># for every (a, b, c), also add (c, b, a)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bend_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mf">2</span><span class="p">]:</span>
            <span class="n">bend_params</span><span class="p">[(</span><span class="n">key</span><span class="p">[</span><span class="mf">2</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mf">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="c"># B) detect all internal coordinates and corresponding energy terms.</span>
    <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># bonds</span>
    <span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">bond_params</span><span class="p">[(</span><span class="n">graph</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">graph</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i1</span><span class="p">])]</span>
        <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BondStretchTerm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">))</span>
    <span class="c"># bends (see b_bending_angles.py for the explanation)</span>
    <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">n</span><span class="p">[:</span><span class="n">index</span><span class="p">]:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">bend_params</span><span class="p">[(</span><span class="n">graph</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">graph</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">graph</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i2</span><span class="p">])]</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BendAngleTerm</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">))</span>

    <span class="c"># C) Create and return the force field</span>
    <span class="k">return</span> <span class="n">ForceField</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>


<span class="c"># This if block is only executed when this file is ran as a program, and not</span>
<span class="c"># when it is loaded as a module.</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">propane</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s">&quot;propane.xyz&quot;</span><span class="p">)</span>
    <span class="n">propane</span><span class="o">.</span><span class="n">set_default_graph</span><span class="p">()</span>
    <span class="n">ff</span> <span class="o">=</span> <span class="n">setup_hydrocarbon_ff</span><span class="p">(</span><span class="n">propane</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">hessian</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">propane</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;The Hessian in kcal/mol/angstrom**2&quot;</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">kcalmol</span><span class="o">/</span><span class="n">angstrom</span><span class="o">**</span><span class="mf">2</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">hessian</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="si">% 5.0f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="dft-hessian-in-internal-coordinates-stationary-geometries">
<h3>DFT Hessian in <cite>internal coordinates</cite> &#8211; Stationary geometries<a class="headerlink" href="#dft-hessian-in-internal-coordinates-stationary-geometries" title="Permalink to this headline">¶</a></h3>
<p>Given a DFT Hessian for a stationary molecular system, and a list of internal
coordinates, <img class="math" src="../_images/math/6b50b1e2a036e3897de5cd74a367b0a7da70d160.png" alt="q_i"/>, one may construct a model for the Hessian based on a
complete second order expansion in terms of internal coordinates. This means
that one uses a force-field model with all possible cross terms as follows:</p>
<div class="math">
<p><img src="../_images/math/8c34d182806b129e825a00a43f44734611101e45.png" alt="E_{\text{FF}} = \sum_{i_1=1}^M
\sum_{i_2=1}^M
K_{i_1 i_2} (q_{i_1} - q_{i_1,0}) (q_{i_2} - q_{i_2,0})" /></p>
</div><p>One can define internal force constants, <img class="math" src="../_images/math/fa64b63b0947a2be73c32ec2b82ddd8c5b55728b.png" alt="K_{ij}"/> such that the
force-field Hessian coincides with a given Hessian from a DFT computation. One
could call the matrix <img class="math" src="../_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/> the Hessian in <cite>internal coordinates</cite>, but as
we will see below, this not a very strict definition. The purpose of such a
transformation is that the matrix <img class="math" src="../_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/> is (or can be made) more diagonally
dominant than the original Hessian. It is a tool to get insight in the
contributions to the Hessian that one should include in a force-field model.
Similar models are used in redundant optimization methods.</p>
<p>Assuming that the geometry is at a stationary point of the potential energy
surface, one has to following expression for the force-field Hessian:</p>
<div class="math">
<p><img src="../_images/math/a56f41c81766009256d0083931f6652e34f273d4.png" alt="\frac{\partial^2 E_{\text{FF}}}{\partial x_{j_1} \partial x_{j_2}}
= \sum_{i_1=1}^M \sum_{i_2=1}^M
K_{i_1 i_2} \left(
    \frac{\partial q_{i_1}}{\partial x_{j_1}}
    \frac{\partial q_{i_2}}{\partial x_{j_2}}
    +\frac{\partial q_{i_1}}{\partial x_{j_2}}
    \frac{\partial q_{i_2}}{\partial x_{j_1}}
\right)
= 2\sum_{i_1=1}^M \sum_{i_2=1}^M
K_{i_1 i_2}
\frac{\partial q_{i_1}}{\partial x_{j_1}}
\frac{\partial q_{i_2}}{\partial x_{j_2}}" /></p>
</div><p>The last step assumes that <img class="math" src="../_images/math/b90654c7e5b6e212986d76795c3c01facdb196f3.png" alt="K_{i_1 i_2} = K_{i_2 i_1}"/>. This can be
rewritten in matrix notation:</p>
<div class="math" id="equation-matrix_hessian_int">
<p><span class="eqno">(1)</span><img src="../_images/math/e519bc1e6500ccae2975fee896a32f6db55ae719.png" alt="H = J K J^T" /></p>
</div><p>with</p>
<div class="math">
<p><img src="../_images/math/18939994ad93819dda63ba7ce82b12ae1e1b4286.png" alt="\begin{align*}
    H_{j_1 j_2} &amp; = \frac{\partial^2 E_{\text{FF}}}{\partial x_{j_1} \partial x_{j_2}} \\
    J_{j_1 i_i} &amp; = \frac{\partial q_{i_1}}{\partial x_{j_1}}
\end{align*}" /></p>
</div><p>In practice, the Jacobian matrix <img class="math" src="../_images/math/abb5588023cfa1ac14643e9778699f03eecc57a3.png" alt="J"/> is rectangular, mainly because there
are often much more internal coordinates than Cartesian coordinates. Therefore
one can not simply invert <a href="#equation-matrix_hessian_int">(1)</a> to obtain the Hessian in
internal coordinates. There are actually many matrices <img class="math" src="../_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/> that solve
equation <a href="#equation-matrix_hessian_int">(1)</a>, and one has to introduce some additional
criteria to fix <img class="math" src="../_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/>.</p>
<p>For the sake of simplicity, we will use the <a class="reference external" href="http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse">Moore-Penrose pseudoinverse</a> of the
Jacobian to invert <a href="#equation-matrix_hessian_int">(1)</a>, but there may be better choices.
This may seem a unique choice, but in practice it is not. The problem is that
the columns of the Jacobian can have different units. Therefore the numerical
Jacobian and its pseudoinverse depend on the choice of the units. Again, we make
a simple choice here to solve this issue: all columns where the internal
coordinates are some sort of distance, are kept as is. All angles are converted
to a length unit with a fixed conversion factor: c = 1Å / 5°. Again, there may
be better choices, e.g. one may normalize the columns of the Jacobian.</p>
<p>The program below performs such an inversion on a DFT Hessian of the for the
dopamine molecule, using all bond lengths, bending angles and dihedral angles.
The script is written in an object-oriented style: each internal coordinate is
an object of the class <tt class="docutils literal"><span class="pre">BondLength</span></tt>, <tt class="docutils literal"><span class="pre">BendingAngle</span></tt> or <tt class="docutils literal"><span class="pre">DihdralAngle</span></tt>.
These three classes are derived from <tt class="docutils literal"><span class="pre">InternalCoordinates</span></tt> and share a common
<a class="reference external" href="http://en.wikipedia.org/wiki/Application_programming_interface">API</a> such
that the main program does not have to worry about the nature of the internal
coordinates.</p>
<p>The Hessian is computed with a Gaussian03 B3LYP/6-31G(d) frequency job. The
result is stored in the file <tt class="docutils literal"><span class="pre">dopamine.fchk</span></tt>, which is a stripped version of the
file generated by the <tt class="docutils literal"><span class="pre">fromchk</span></tt> program that is part of Gaussian03.</p>
<p>File: <tt class="docutils literal"><span class="pre">examples/003_internal_coordinates/d_dft_hessian.py</span></tt></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161</pre></td><td class="code"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># MolMod is a collection of molecular modelling tools for python.</span>
<span class="c"># Copyright (C) 2007 - 2012 Toon Verstraelen &lt;Toon.Verstraelen@UGent.be&gt;, Center</span>
<span class="c"># for Molecular Modeling (CMM), Ghent University, Ghent, Belgium; all rights</span>
<span class="c"># reserved unless otherwise stated.</span>
<span class="c">#</span>
<span class="c"># This file is part of MolMod.</span>
<span class="c">#</span>
<span class="c"># MolMod is free software; you can redistribute it and/or</span>
<span class="c"># modify it under the terms of the GNU General Public License</span>
<span class="c"># as published by the Free Software Foundation; either version 3</span>
<span class="c"># of the License, or (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># MolMod is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<span class="c">#</span>
<span class="c">#--</span>
<span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">molmod</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.io</span> <span class="kn">import</span> <span class="n">FCHKFile</span>


<span class="k">class</span> <span class="nc">InternalCoordinate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for all internal coordinates.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">icfn</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">           Arguments:</span>
<span class="sd">            | ``indexes`` -- The indexes of the atoms in the internal</span>
<span class="sd">                             coordinate. The order must be the same as the order</span>
<span class="sd">                             of the mandatory arguments of icfn.</span>
<span class="sd">            | ``icfn`` -- a function from molmod.ic that can compute the</span>
<span class="sd">                          internal coordinate and its derivatives.</span>
<span class="sd">            | ``conversion`` -- In case the internal coordinate does not have a</span>
<span class="sd">                                unit of length, then this conversion factor is</span>
<span class="sd">                                used to convert it to a length unit. This way,</span>
<span class="sd">                                the Jacobian becomes a dimensionless constant.</span>

<span class="sd">           All the Jacobian-logic is implemented in this abstract class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">icfn</span> <span class="o">=</span> <span class="n">icfn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span>

    <span class="k">def</span> <span class="nf">fill_jacobian_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jaccol</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill in a column of the Jacobian.</span>

<span class="sd">           Arguments:</span>
<span class="sd">            | ``jaccol`` -- The column of Jacobian to which the result must be</span>
<span class="sd">                            added.</span>
<span class="sd">            | ``coordinates`` -- A numpy array with Cartesian coordinates,</span>
<span class="sd">                                 shape=(N,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">icfn</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">)],</span> <span class="mf">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">):</span>
            <span class="n">jaccol</span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mf">3</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mf">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">jaccol</span>


<span class="k">class</span> <span class="nc">BondLength</span><span class="p">(</span><span class="n">InternalCoordinate</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">):</span>
        <span class="n">InternalCoordinate</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">),</span> <span class="n">bond_length</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BendingAngle</span><span class="p">(</span><span class="n">InternalCoordinate</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="n">InternalCoordinate</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">),</span> <span class="n">bend_angle</span><span class="p">,</span> <span class="n">angstrom</span><span class="o">/</span><span class="p">(</span><span class="mf">5</span><span class="o">*</span><span class="n">deg</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">DihedralAngle</span><span class="p">(</span><span class="n">InternalCoordinate</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">):</span>
        <span class="n">InternalCoordinate</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">),</span> <span class="n">dihed_angle</span><span class="p">,</span> <span class="n">angstrom</span><span class="o">/</span><span class="p">(</span><span class="mf">5</span><span class="o">*</span><span class="n">deg</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">setup_ics</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a list of internal coordinates based on the graph</span>

<span class="sd">       Argument:</span>
<span class="sd">        | ``graph`` -- A Graph instance.</span>

<span class="sd">       The list of internal coordinates will include all bond lengths, all</span>
<span class="sd">       bending angles, and all dihedral angles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ics</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># A) Collect all bonds.</span>
    <span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">ics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BondLength</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">))</span>
    <span class="c"># B) Collect all bends. (see b_bending_angles.py for the explanation)</span>
    <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">n</span><span class="p">[:</span><span class="n">index</span><span class="p">]:</span>
                <span class="n">ics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BendingAngle</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">))</span>
    <span class="c"># C) Collect all dihedrals.</span>
    <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i0</span><span class="o">==</span><span class="n">i2</span><span class="p">:</span>
                <span class="c"># All four indexes must be different.</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i3</span><span class="o">==</span><span class="n">i1</span> <span class="ow">or</span> <span class="n">i3</span><span class="o">==</span><span class="n">i0</span><span class="p">:</span>
                    <span class="c"># All four indexes must be different.</span>
                    <span class="k">continue</span>
                <span class="n">ics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DihedralAngle</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ics</span>


<span class="k">def</span> <span class="nf">compute_jacobian</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a Jacobian for the given internal and Cartesian coordinates</span>

<span class="sd">       Arguments:</span>
<span class="sd">        | ``ics`` -- A list of internal coordinate objects.</span>
<span class="sd">        | ``coordinates`` -- A numpy array with Cartesian coordinates,</span>
<span class="sd">                             shape=(N,3)</span>

<span class="sd">       The return value will be a numpy array with the Jacobian matrix. There</span>
<span class="sd">       will be a column for each internal coordinate, and a row for each</span>
<span class="sd">       Cartesian coordinate (3*N rows).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N3</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span>
    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ics</span><span class="p">)),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ics</span><span class="p">):</span>
        <span class="c"># Let the ic object fill in each column of the Jacobian.</span>
        <span class="n">ic</span><span class="o">.</span><span class="n">fill_jacobian_column</span><span class="p">(</span><span class="n">jacobian</span><span class="p">[:,</span><span class="n">j</span><span class="p">],</span> <span class="n">coordinates</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jacobian</span>


<span class="c"># This if block is only executed when this file is ran as a program, and not</span>
<span class="c"># when it is loaded as a module.</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c"># Load the formatted checkpoint file with the frequency computation. This</span>
    <span class="c"># file also contains the atomic numbers and the coordinates of the atoms,</span>
    <span class="c"># and therefore one can access the dopamine molecule object through</span>
    <span class="c"># fchk.molecule.</span>
    <span class="n">fchk</span> <span class="o">=</span> <span class="n">FCHKFile</span><span class="p">(</span><span class="s">&quot;dopamine.fchk&quot;</span><span class="p">)</span>
    <span class="c"># Set the default graph for the construction of the internal coordinates:</span>
    <span class="n">fchk</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">set_default_graph</span><span class="p">()</span>
    <span class="c"># Setup a list of internal coordinates</span>
    <span class="n">ics</span> <span class="o">=</span> <span class="n">setup_ics</span><span class="p">(</span><span class="n">fchk</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
    <span class="c"># Compute the Jacobian.</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">compute_jacobian</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">fchk</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="c"># Compute the pseudo-inverse, using a loose threshold for the singular</span>
    <span class="c"># values to filter out equivalent internal coordinates.</span>
    <span class="n">Jinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
    <span class="c"># Get the Hessian in Cartesian coordinates.</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">fchk</span><span class="o">.</span><span class="n">get_hessian</span><span class="p">()</span>
    <span class="c"># Transform to internal coordinates.</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Jinv</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Jinv</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>
    <span class="c"># Make a nice printout of K.</span>
    <span class="k">print</span> <span class="s">&quot;The Hessian in internal coordinates in kcal/mol/angstrom**2&quot;</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">kcalmol</span><span class="o">/</span><span class="n">angstrom</span><span class="o">**</span><span class="mf">2</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">K</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="si">% 5.0f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>For the computation of the pseudo-inverse, there is one more gotcha&#8217;s: some
internal coordinates are exactly redundant, i.e. in the case of dopamine, the
the dihedral angles in the aromatic ring are a bit problematic. It is comparable
to the situation of ethene, where one dihdral angle can always be written as a
simple linear function of the three other ones. The columns in the Jacobian
corresponding to these dihedrals are linearly dependent. One can in principle
leave out 6 columns in the case of dopamine. However, any selection of internal
coordinates to be removed would be a subjective choice. One can avoid such
subjective input by dropping the almost-zero singular values during he
computation of the generalized inverse. Therefore the second argument to
<tt class="docutils literal"><span class="pre">pinv</span></tt> in the script is set to <tt class="docutils literal"><span class="pre">1e-5</span></tt>, which means that all singular values
that are 100000 times smaller than the largest one, are treated as if they were
zeros.</p>
</div>
</div>
<div class="section" id="problems">
<h2>Problems<a class="headerlink" href="#problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="all-bond-ch-bond-lengths-in-propane">
<h3>All bond CH-bond lengths in propane<a class="headerlink" href="#all-bond-ch-bond-lengths-in-propane" title="Permalink to this headline">¶</a></h3>
<p>Write a program that computes all CH-bond lengths in the propane molecule. Use
the same style as in the example that computes the bending angles in the
dopamine molecule.</p>
</div>
<div class="section" id="more-complete-force-field-hessian">
<h3>More complete Force-field Hessian<a class="headerlink" href="#more-complete-force-field-hessian" title="Permalink to this headline">¶</a></h3>
<p>Modify the program that computes the Hessian of propane in such a way that it
takes into account the contributions due to deviations of internal coordinates
from the rest value of each force-field term.</p>
</div>
<div class="section" id="dft-hessian-in-internal-coordinates-non-stationary-geometries">
<h3>DFT Hessian in <cite>internal coordinates</cite> &#8211; Non-stationary geometries<a class="headerlink" href="#dft-hessian-in-internal-coordinates-non-stationary-geometries" title="Permalink to this headline">¶</a></h3>
<p>Extend the program for the computation of the Hessian in internal coordinates
such that it also works for non-stationery points on the potential energy
surface. The starting point is a more general expression for the force-field
model</p>
<div class="math">
<p><img src="../_images/math/0a585c1cd1021a86048080a094f2fea11df48fca.png" alt="E_{\text{FF}} =
\sum_{i=1}^M A (q_{i} - q_{i,0}) +
\sum_{i_1=1}^M \sum_{i_2=1}^M
K_{i_1 i_2} (q_{i_1} - q_{i_1,0}) (q_{i_2} - q_{i_2,0})" /></p>
</div><p>where the rest values can be the current internal coordinates, or some reference
values. The vector <img class="math" src="../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> and the matrix <img class="math" src="../_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/> can be defined in such
a way that the force-field gradient and Hessian in Cartesian coordinates
coincide with their DFT counter-parts. First derive proper forms for <img class="math" src="../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/>
and <img class="math" src="../_images/math/dfb064112b6c94470339f6571f69d07afc1c024c.png" alt="K"/>.</p>
<p>Let the program still use the current internal coordinates as reference values
for the force field. Let it also print out the vector <img class="math" src="../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/>.</p>
</div>
<div class="section" id="fitting-force-constants">
<h3>Fitting force-constants<a class="headerlink" href="#fitting-force-constants" title="Permalink to this headline">¶</a></h3>
<p>Write a program that fits the force-constants of the propane molecule based on a
DFT Hessian computation on the ground-state geometry, for given values of the
rest lengths and angles. Test to what extent these force constants depend on the
choice of rest parameters.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference external" href="#">Internal coordinates</a><ul>
<li><a class="reference external" href="#introduction">Introduction</a></li>
<li><a class="reference external" href="#examples">Examples</a><ul>
<li><a class="reference external" href="#a-simple-bond-length">A simple bond length</a></li>
<li><a class="reference external" href="#all-bending-angles-in-dopamine">All bending angles in dopamine</a></li>
<li><a class="reference external" href="#simple-force-field-hessian">Simple Force-field Hessian</a></li>
<li><a class="reference external" href="#dft-hessian-in-internal-coordinates-stationary-geometries">DFT Hessian in <cite>internal coordinates</cite> &#8211; Stationary geometries</a></li>
</ul>
</li>
<li><a class="reference external" href="#problems">Problems</a><ul>
<li><a class="reference external" href="#all-bond-ch-bond-lengths-in-propane">All bond CH-bond lengths in propane</a></li>
<li><a class="reference external" href="#more-complete-force-field-hessian">More complete Force-field Hessian</a></li>
<li><a class="reference external" href="#dft-hessian-in-internal-coordinates-non-stationary-geometries">DFT Hessian in <cite>internal coordinates</cite> &#8211; Non-stationary geometries</a></li>
<li><a class="reference external" href="#fitting-force-constants">Fitting force-constants</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="graph.html"
                        title="previous chapter">Working with molecular graphs</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="patterns.html"
                        title="next chapter">Pattern-matching in molecular graphs</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/tutorial/internal_coordinates.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="patterns.html" title="Pattern-matching in molecular graphs"
             >next</a> |</li>
        <li class="right" >
          <a href="graph.html" title="Working with molecular graphs"
             >previous</a> |</li>
        <li><a href="../index.html">MolMod v0.0 documentation</a> &raquo;</li>
          <li><a href="examples.html" >MolMod by example</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Toon Verstraelen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.
    </div>
  </body>
</html>